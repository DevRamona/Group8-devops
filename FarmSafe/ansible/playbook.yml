---
- hosts: all
  become: yes
  vars:
    # Variables passed via --extra-vars
    docker_registry: "{{ docker_registry | default('') }}"
    backend_image: "{{ backend_image | default('') }}"
    frontend_image: "{{ frontend_image | default('') }}"
    aws_region: "{{ aws_region | default('us-east-1') }}"
    ecr_token: "{{ ecr_token | default('') }}"
    jwt_secret: "{{ jwt_secret | default('changeme') }}"

  tasks:
    # --- System Preparation Tasks (Swap File) ---

    - name: Check if swap file exists
      stat:
        path: /swapfile
      register: swap_file

    - name: Create swap file
      command: dd if=/dev/zero of=/swapfile bs=128M count=16
      when: not swap_file.stat.exists

    - name: Set swap file permissions
      file:
        path: /swapfile
        mode: '0600'
      when: not swap_file.stat.exists

    - name: Format swap file
      command: mkswap /swapfile
      when: not swap_file.stat.exists

    - name: Enable swap file
      command: swapon /swapfile
      when: not swap_file.stat.exists

    # --- System Setup Tasks (Package Installation) ---

    # NOTE: The manual `which pip3`/`which unzip` checks and debug tasks are removed.
    # The fix is to ensure these packages are installed first.

    - name: Update package index (dnf)
      dnf:
        update_cache: yes
      become: yes

    - name: Install required system packages (Docker, Python/Pip, Utilities)
      dnf:
        name:
          - python3-pip           # <--- FIX: Essential for the `pip` module to work
          - docker
          - unzip                 # <--- FIX: Ensure unzip is available (if needed)
          - python3-dnf-plugin-versionlock
          - docker-compose-plugin # <--- FIX: Install modern Docker Compose CLI plugin
        state: present
      become: yes

    - name: Create Docker CLI plugins directory
      file:
        path: /usr/local/lib/docker/cli-plugins
        state: directory
        mode: '0755'
      become: yes

    # The original "Install Docker Compose" task is REMOVED because 
    # the package is installed via DNF above.

    - name: Install Python required packages (awscli and docker-py)
      pip:
        name:
          - awscli
          - docker
          - boto3 # Adding boto3 as it is often required for AWS modules/tasks
        executable: pip3
        state: present
      become: yes

    # --- Docker Service and Login Tasks ---

    - name: Start and enable Docker service
      service:
        name: docker
        state: started
        enabled: yes
      become: yes

    - name: Add user to docker group
      user:
        name: "{{ ansible_user }}"
        groups: docker
        append: yes
      become: yes
      # NOTE: This change may require reconnecting or running a separate play to take effect.
      # However, since subsequent tasks use `become_user` with `environment: {HOME: ...}`, 
      # the manual login steps below usually succeed without a full logout/login cycle.

    - name: Configure ECR login using provided token
      when: docker_registry != "" and ecr_token != ""
      shell: |
        echo "{{ ecr_token }}" | docker login --username AWS --password-stdin {{ docker_registry }}
      become_user: "{{ ansible_user }}"
      environment:
        HOME: "/home/{{ ansible_user }}"
      register: ecr_login_token
      changed_when: false
      no_log: true
      # NOTE: This task handles login, eliminating the need for `community.aws.ecr_login`
      # if you provide the ECR token from the CI/CD pipeline.

    - name: Configure ECR login using IAM role (fallback)
      when: docker_registry != "" and ecr_token == ""
      shell: |
        aws ecr get-login-password --region {{ aws_region }} | docker login --username AWS --password-stdin {{ docker_registry }}
      become_user: "{{ ansible_user }}"
      environment:
        AWS_DEFAULT_REGION: "{{ aws_region }}"
        HOME: "/home/{{ ansible_user }}"
      register: ecr_login_iam
      changed_when: false
      failed_when: ecr_login_iam.rc != 0

    # --- Deployment Tasks ---

    - name: Create application directory
      file:
        path: /opt/farmsafe
        state: directory
        owner: "{{ ansible_user }}"
        group: "{{ ansible_user }}"
        mode: '0755'
      become: yes

    - name: Create production docker-compose file
      when: backend_image != ""
      copy:
        content: |
          services:
            mongodb:
              image: mongo:7.0
              container_name: farmsafe-mongodb
              restart: unless-stopped
              ports:
                - "27017:27017"
              environment:
                MONGO_INITDB_DATABASE: farmsafe_db
              volumes:
                - mongodb_data:/data/db
              healthcheck:
                test: ["CMD", "mongosh", "localhost:27017/farmsafe_db", "--quiet", "--eval", "db.runCommand({ ping: 1 }).ok"]
                interval: 10s
                timeout: 5s
                retries: 5

            backend:
              image: "{{ backend_image | quote }}"
              container_name: farmsafe-backend
              restart: unless-stopped
              environment:
                NODE_ENV: production
                PORT: 5000
                MONGO_URI: mongodb://mongodb:27017/farmsafe_db
                JWT_SECRET: {{ jwt_secret }}
              ports:
                - "5000:5000"
              depends_on:
                mongodb:
                  condition: service_healthy
              healthcheck:
                test: ["CMD", "node", "-e", "require('http').get('http://localhost:5000/', r => process.exit(r.statusCode === 200 ? 0 : 1))"]
                interval: 30s
                timeout: 3s
                retries: 3
                start_period: 10s

            frontend:
              image: "{{ frontend_image | quote }}"
              container_name: farmsafe-frontend
              restart: unless-stopped
              ports:
                - "80:80"
              depends_on:
                backend:
                  condition: service_healthy

          volumes:
            mongodb_data:
              driver: local
        dest: /opt/farmsafe/docker-compose.yml
        owner: "{{ ansible_user }}"
        group: "{{ ansible_user }}"
        mode: '0644'
      become: yes # Use become to ensure permissions are set correctly

    # NOTE: Shell pull tasks are okay, but use the full `docker compose` binary/plugin path if possible
    # or ensure the path is available, which the DNF install should handle.

    - name: Pull backend Docker image
      when: backend_image != ""
      shell: docker pull {{ backend_image | quote }}
      become_user: "{{ ansible_user }}"
      environment:
        HOME: "/home/{{ ansible_user }}"
      register: docker_pull_backend
      retries: 3
      delay: 5

    - name: Pull frontend Docker image
      when: frontend_image != ""
      shell: docker pull {{ frontend_image | quote }}
      become_user: "{{ ansible_user }}"
      environment:
        HOME: "/home/{{ ansible_user }}"
      register: docker_pull_frontend
      retries: 3
      delay: 5

    - name: Stop existing containers
      when: backend_image != ""
      shell: docker compose down # Rely on DNF installed `docker compose` plugin/binary
      args:
        chdir: /opt/farmsafe
      become_user: "{{ ansible_user }}"
      environment:
        HOME: "/home/{{ ansible_user }}"
      ignore_errors: yes

    - name: Start services with docker-compose
      when: backend_image != ""
      shell: docker compose up -d # Rely on DNF installed `docker compose` plugin/binary
      args:
        chdir: /opt/farmsafe
      become_user: "{{ ansible_user }}"
      environment:
        HOME: "/home/{{ ansible_user }}"

    - name: Verify services are running
      when: backend_image != ""
      shell: docker compose ps # Rely on DNF installed `docker compose` plugin/binary
      args:
        chdir: /opt/farmsafe
      become_user: "{{ ansible_user }}"
      environment:
        HOME: "/home/{{ ansible_user }}"
      register: compose_status

    - name: Display service status
      when: backend_image != ""
      debug:
        msg: "{{ compose_status.stdout_lines }}"